export const data = {
  version: 1,
  uniforms: [
    {
      name: "_time",
      type: "float",
      value: 0,
    },
  ],
  vertex:
    "// Created with NodeToy | Three.js r149\n\n// <node_builder>\n\n// uniforms\n\n// attributes\n\n// varys\nvarying vec2 nodeVary0; \n// vars\n\n// codes\n\n// variables\n// </node_builder>\n\n\n\n\n\n\n\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ) * c );\n\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\nfloat luminance( const in vec3 rgb ) {\n\n\t// assumes rgb is in linear color space with sRGB primaries and D65 white point\n\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\n\treturn dot( weights, rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n\treturn m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n\t// dir is assumed to be unit length\n\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\treturn vec2( u, v );\n\n}\n\n\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n\n\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvarying vec4 vColor;\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvarying vec3 vColor;\n\n#endif\n\n\n#ifdef USE_FOG\n\n\tvarying float vFogDepth;\n\n#endif\n\n\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\n\t\t}\n\n\t#else\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\n\t\t#else\n\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\n\tmat4 getBoneMatrix( const in float i ) {\n\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\ty = dy * ( y + 0.5 );\n\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\treturn bone;\n\n\t}\n\n#endif\n\n\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n\n\nvoid main() {\nnodeVary0 = uv;\n\t\n\n\n\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n\n\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n\n\n#if defined( USE_COLOR_ALPHA )\n\n\tvColor = vec4( 1.0 );\n\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n\tvColor = vec3( 1.0 );\n\n#endif\n\n#ifdef USE_COLOR\n\n\tvColor *= color;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n\tvColor.xyz *= instanceColor.xyz;\n\n#endif\n\n\n#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tvColor *= morphTargetBaseInfluence;\n\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t#if defined( USE_COLOR_ALPHA )\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\n\t\t#elif defined( USE_COLOR )\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\n\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n\n\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n\n\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n\n\n\t#endif\n\n\nvec3 transformed = vec3( position );\n\n\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\n\t#ifdef MORPHTARGETS_TEXTURE\n\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\n\t\t}\n\n\t#else\n\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t\t#ifndef USE_MORPHNORMALS\n\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n\n\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n\n\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n\n\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n\n\tvViewPosition = - mvPosition.xyz;\n\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n\n\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex;\n\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\t}\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n\n#ifdef USE_FOG\n\n\tvFogDepth = - mvPosition.z;\n\n#endif\n\n\t\n\tgl_Position = vec4(position, 1.0);\n}\n\n\n",
  fragment:
    "// Created with NodeToy | Three.js r149\n\n// <node_builder>\n\n// uniforms\nuniform float _time; \n// attributes\n\n// varys\nvarying vec2 nodeVary0; \n// vars\nvec2 nodeVar0; float nodeVar1; float nodeVar2; float nodeVar3; vec2 nodeVar4; vec3 nodeVar5; float nodeVar6; vec4 nodeVar7; float nodeVar8; vec2 nodeVar9; float nodeVar10; float nodeVar11; vec2 nodeVar12; vec2 nodeVar13; vec3 nodeVar14; float nodeVar15; vec4 nodeVar16; vec4 nodeVar17; vec4 nodeVar18; vec4 nodeVar19; vec4 nodeVar20; \n// codes\nvec4 customFn_knb8C2HJmfz8 ( vec4 blendOpSrc, vec4 blendOpDest, float opacity, float opacityMask ) {\n                \n    float alpha = clamp(opacity * opacityMask, 0.0, 1.0);\n    vec4 temp;\n    temp.x = (blendOpDest.x > 0.5) ? (1.0-(1.0-2.0*(blendOpDest.x-0.5))*(1.0-blendOpSrc.x)) : (2.0*blendOpDest.x)*blendOpSrc.x;\n    temp.y = (blendOpDest.y > 0.5) ? (1.0-(1.0-2.0*(blendOpDest.y-0.5))*(1.0-blendOpSrc.y)) : (2.0*blendOpDest.y)*blendOpSrc.y;\n    temp.z = (blendOpDest.z > 0.5) ? (1.0-(1.0-2.0*(blendOpDest.z-0.5))*(1.0-blendOpSrc.z)) : (2.0*blendOpDest.z)*blendOpSrc.z;\n    temp.w = (blendOpDest.w > 0.5) ? (1.0-(1.0-2.0*(blendOpDest.w-0.5))*(1.0-blendOpSrc.w)) : (2.0*blendOpDest.w)*blendOpSrc.w;\n    vec4 mixBlendMode = mix(blendOpDest, temp, alpha);\n    \n    \n    return (clamp(mixBlendMode,0.0,1.0)).xyzw;\n    \n            \n            }\nvec4 customFn_Bo3YhN5AXwYL ( vec4 blendOpSrc, vec4 blendOpDest, float opacity, float opacityMask ) {\n                \n    float alpha = clamp(opacity * opacityMask, 0.0, 1.0);\n    vec4 mixBlendMode = mix(blendOpDest,( 1.0 - ( ( 1.0 - blendOpDest) / max( blendOpSrc, 0.00001) ) ), alpha);\n    \n    \n    return (clamp(mixBlendMode,0.0,1.0)).xyzw;\n    \n            \n            }\nvec4 customFn_2Vd3wdzIwtQf ( float time ) {\n                \n    \n    //    <3\n    //       <3\n    //    <3\n    // <3\n\n    // Gradient struct\n    struct Gradient {\n        vec4 colors[8];\n        vec2 alphas[8];\n        float colorsLength;\n        float alphasLength;\n        float type;\n    };\n\n    // Gradient  ~ - ~ - ~\n    Gradient gradient;\n    gradient.type = 0.0;\n    gradient.colors = vec4[8](vec4(float(0.8980392156862745),float(0.8980392156862745),float(0.8980392156862745),float(0.000)),vec4(float(0.27450980392156865),float(0.27450980392156865),float(0.27450980392156865),float(1.000)),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0));\n    gradient.alphas = vec2[8](vec2(float(1),float(0)),vec2(float(1),float(1)),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0));\n    gradient.colorsLength = float(2);\n    gradient.alphasLength = float(2);\n\n    vec3 color = gradient.colors[0].rgb;\n\n    for (int c = 1; c < 8; c++)\n    {\n        float colorPos = clamp((time - gradient.colors[c-1].w) / (gradient.colors[c].w - gradient.colors[c-1].w), 0.0, 1.0) * step(float(c), gradient.colorsLength-1.0);\n        color = mix(color, gradient.colors[c].rgb, mix(colorPos, step(0.01, colorPos), gradient.type));\n    }\n    \n\n    float alpha = gradient.alphas[0].x;\n    for (int a = 1; a < 8; a++)\n    {\n        float alphaPos = clamp((time - gradient.alphas[a-1].y) / (gradient.alphas[a].y - gradient.alphas[a-1].y), 0.0, 1.0) * step(float(a), gradient.alphasLength-1.0);\n        alpha = mix(alpha, gradient.alphas[a].x, mix(alphaPos, step(0.01, alphaPos), gradient.type));\n    }\n    return vec4(color, alpha);\n    \n            }\nvec3 mod3D289_kao7xDNkNSqq ( vec3 x ) { return x - floor( x / 289.0 ) * 289.0; }\n\n    vec4 mod3D289_kao7xDNkNSqq( vec4 x ) { return x - floor( x / 289.0 ) * 289.0; }\n\n    vec4 permute_kao7xDNkNSqq( vec4 x ) { return mod3D289_kao7xDNkNSqq( ( x * 34.0 + 1.0 ) * x ); }\n\n    vec4 taylorInvSqrt_kao7xDNkNSqq( vec4 r ) { return 1.79284291400159 - r * 0.85373472095314; }\n\n    float snoise_kao7xDNkNSqq( vec3 v ){\n        const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n        vec3 i = floor( v + dot( v, C.yyy ) );\n        vec3 x0 = v - i + dot( i, C.xxx );\n        vec3 g = step( x0.yzx, x0.xyz );\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy;\n        vec3 x3 = x0 - 0.5;\n        i = mod3D289_kao7xDNkNSqq( i);\n        vec4 p = permute_kao7xDNkNSqq( permute_kao7xDNkNSqq( permute_kao7xDNkNSqq( i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) ) + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n        vec4 j = p - 49.0 * floor( p / 49.0 );  \n        vec4 x_ = floor( j / 7.0 );\n        vec4 y_ = floor( j - 7.0 * x_ );  // mod(j,N)\n        vec4 x = ( x_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n        vec4 y = ( y_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n        vec4 h = 1.0 - abs( x ) - abs( y );\n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n        vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n        vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n        vec4 sh = -step( h, vec4(0.0,0.0,0.0,0.0) );\n        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n        vec3 g0 = vec3( a0.xy, h.x );\n        vec3 g1 = vec3( a0.zw, h.y );\n        vec3 g2 = vec3( a1.xy, h.z );\n        vec3 g3 = vec3( a1.zw, h.w );\n        vec4 norm = taylorInvSqrt_kao7xDNkNSqq( vec4( dot( g0, g0 ), dot( g1, g1 ), dot( g2, g2 ), dot( g3, g3 ) ) );\n        g0 *= norm.x;\n        g1 *= norm.y;\n        g2 *= norm.z;\n        g3 *= norm.w;\n        vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n        m = m* m;\n        m = m* m;\n        vec4 px = vec4( dot( x0, g0 ), dot( x1, g1 ), dot( x2, g2 ), dot( x3, g3 ) );\n        return 42.0 * dot( m, px);\n    }\nfloat customFn_3nW8QQkpfhOY ( vec2 uv, float scale ) {\n                \n    float noise = snoise_kao7xDNkNSqq( vec3(uv.x,uv.y,0.0) * scale );\n    \n    noise = noise*0.5 + 0.5;\n    return noise;\n    \n            \n            }\nvec4 customFn_tPu9aVt5rBQE ( float time ) {\n                \n    \n    //    <3\n    //       <3\n    //    <3\n    // <3\n\n    // Gradient struct\n    struct Gradient {\n        vec4 colors[8];\n        vec2 alphas[8];\n        float colorsLength;\n        float alphasLength;\n        float type;\n    };\n\n    // Gradient  ~ - ~ - ~\n    Gradient gradient;\n    gradient.type = 0.0;\n    gradient.colors = vec4[8](vec4(float(0.49019607843137253),float(0.49019607843137253),float(0.49019607843137253),float(0.000)),vec4(float(0.6901960784313725),float(0.6901960784313725),float(0.6901960784313725),float(1.000)),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0));\n    gradient.alphas = vec2[8](vec2(float(1),float(0)),vec2(float(1),float(1)),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0));\n    gradient.colorsLength = float(2);\n    gradient.alphasLength = float(2);\n\n    vec3 color = gradient.colors[0].rgb;\n\n    for (int c = 1; c < 8; c++)\n    {\n        float colorPos = clamp((time - gradient.colors[c-1].w) / (gradient.colors[c].w - gradient.colors[c-1].w), 0.0, 1.0) * step(float(c), gradient.colorsLength-1.0);\n        color = mix(color, gradient.colors[c].rgb, mix(colorPos, step(0.01, colorPos), gradient.type));\n    }\n    \n\n    float alpha = gradient.alphas[0].x;\n    for (int a = 1; a < 8; a++)\n    {\n        float alphaPos = clamp((time - gradient.alphas[a-1].y) / (gradient.alphas[a].y - gradient.alphas[a-1].y), 0.0, 1.0) * step(float(a), gradient.alphasLength-1.0);\n        alpha = mix(alpha, gradient.alphas[a].x, mix(alphaPos, step(0.01, alphaPos), gradient.type));\n    }\n    return vec4(color, alpha);\n    \n            }\nvec3 mod3D289_CWIv36G3ayU5 ( vec3 x ) { return x - floor( x / 289.0 ) * 289.0; }\n\n    vec4 mod3D289_CWIv36G3ayU5( vec4 x ) { return x - floor( x / 289.0 ) * 289.0; }\n\n    vec4 permute_CWIv36G3ayU5( vec4 x ) { return mod3D289_CWIv36G3ayU5( ( x * 34.0 + 1.0 ) * x ); }\n\n    vec4 taylorInvSqrt_CWIv36G3ayU5( vec4 r ) { return 1.79284291400159 - r * 0.85373472095314; }\n\n    float snoise_CWIv36G3ayU5( vec3 v ){\n        const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n        vec3 i = floor( v + dot( v, C.yyy ) );\n        vec3 x0 = v - i + dot( i, C.xxx );\n        vec3 g = step( x0.yzx, x0.xyz );\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy;\n        vec3 x3 = x0 - 0.5;\n        i = mod3D289_CWIv36G3ayU5( i);\n        vec4 p = permute_CWIv36G3ayU5( permute_CWIv36G3ayU5( permute_CWIv36G3ayU5( i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) ) + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n        vec4 j = p - 49.0 * floor( p / 49.0 );  \n        vec4 x_ = floor( j / 7.0 );\n        vec4 y_ = floor( j - 7.0 * x_ );  // mod(j,N)\n        vec4 x = ( x_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n        vec4 y = ( y_ * 2.0 + 0.5 ) / 7.0 - 1.0;\n        vec4 h = 1.0 - abs( x ) - abs( y );\n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n        vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n        vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n        vec4 sh = -step( h, vec4(0.0,0.0,0.0,0.0) );\n        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n        vec3 g0 = vec3( a0.xy, h.x );\n        vec3 g1 = vec3( a0.zw, h.y );\n        vec3 g2 = vec3( a1.xy, h.z );\n        vec3 g3 = vec3( a1.zw, h.w );\n        vec4 norm = taylorInvSqrt_CWIv36G3ayU5( vec4( dot( g0, g0 ), dot( g1, g1 ), dot( g2, g2 ), dot( g3, g3 ) ) );\n        g0 *= norm.x;\n        g1 *= norm.y;\n        g2 *= norm.z;\n        g3 *= norm.w;\n        vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n        m = m* m;\n        m = m* m;\n        vec4 px = vec4( dot( x0, g0 ), dot( x1, g1 ), dot( x2, g2 ), dot( x3, g3 ) );\n        return 42.0 * dot( m, px);\n    }\nfloat customFn_UgLkUzErn76G ( vec2 uv, float scale ) {\n                \n    float noise = snoise_CWIv36G3ayU5( vec3(uv.x,uv.y,0.0) * scale );\n    \n    noise = noise*0.5 + 0.5;\n    return noise;\n    \n            \n            }\nvec3 mod2D289_9DQdJiDWd8qI ( vec3 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec2 mod2D289_9DQdJiDWd8qI( vec2 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec3 permute_9DQdJiDWd8qI( vec3 x ) { return mod2D289_9DQdJiDWd8qI( ( ( x * 34.0 ) + 1.0 ) * x ); }\n\n    float snoise_9DQdJiDWd8qI( vec2 v ){\n        const vec4 C = vec4( 0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439 );\n        vec2 i = floor( v + dot( v, C.yy ) );\n        vec2 x0 = v - i + dot( i, C.xx );\n        vec2 i1;\n        i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n        i = mod2D289_9DQdJiDWd8qI( i );\n        vec3 p = permute_9DQdJiDWd8qI( permute_9DQdJiDWd8qI( i.y + vec3( 0.0, i1.y, 1.0 ) ) + i.x + vec3( 0.0, i1.x, 1.0 ) );\n        vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n        m = m * m;\n        m = m * m;\n        vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n        vec3 h = abs( x ) - 0.5;\n        vec3 ox = floor( x + 0.5 );\n        vec3 a0 = x - ox;\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n        vec3 g;\n        g.x = a0.x * x0.x + h.x * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot( m, g );\n    }\nfloat customFn_unUZVvdgXnqk ( vec2 uv, float scale ) {\n                \n    float noise = snoise_9DQdJiDWd8qI( uv * scale );\n    \n    noise = noise*0.5 + 0.5;\n    return noise;\n    \n            \n            }\nvec3 mod2D289_mXOXXGlG5T7g ( vec3 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec2 mod2D289_mXOXXGlG5T7g( vec2 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n\n\tvec3 permute_mXOXXGlG5T7g( vec3 x ) { return mod2D289_mXOXXGlG5T7g( ( ( x * 34.0 ) + 1.0 ) * x ); }\n\n    float snoise_mXOXXGlG5T7g( vec2 v ){\n        const vec4 C = vec4( 0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439 );\n        vec2 i = floor( v + dot( v, C.yy ) );\n        vec2 x0 = v - i + dot( i, C.xx );\n        vec2 i1;\n        i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n        i = mod2D289_mXOXXGlG5T7g( i );\n        vec3 p = permute_mXOXXGlG5T7g( permute_mXOXXGlG5T7g( i.y + vec3( 0.0, i1.y, 1.0 ) ) + i.x + vec3( 0.0, i1.x, 1.0 ) );\n        vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n        m = m * m;\n        m = m * m;\n        vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n        vec3 h = abs( x ) - 0.5;\n        vec3 ox = floor( x + 0.5 );\n        vec3 a0 = x - ox;\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n        vec3 g;\n        g.x = a0.x * x0.x + h.x * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot( m, g );\n    }\nfloat customFn_6SEM4D3cwUVc ( vec2 uv, float scale ) {\n                \n    float noise = snoise_mXOXXGlG5T7g( uv * scale );\n    \n    noise = noise*0.5 + 0.5;\n    return noise;\n    \n            \n            }\nvec4 customFn_vp5SjOUmFgl4 ( float time ) {\n                \n    \n    //    <3\n    //       <3\n    //    <3\n    // <3\n\n    // Gradient struct\n    struct Gradient {\n        vec4 colors[8];\n        vec2 alphas[8];\n        float colorsLength;\n        float alphasLength;\n        float type;\n    };\n\n    // Gradient  ~ - ~ - ~\n    Gradient gradient;\n    gradient.type = 0.0;\n    gradient.colors = vec4[8](vec4(float(1),float(1),float(1),float(0.000)),vec4(float(0),float(0),float(0),float(1.000)),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0));\n    gradient.alphas = vec2[8](vec2(float(1),float(0)),vec2(float(1),float(1)),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(0.0,0.0));\n    gradient.colorsLength = float(2);\n    gradient.alphasLength = float(2);\n\n    vec3 color = gradient.colors[0].rgb;\n\n    for (int c = 1; c < 8; c++)\n    {\n        float colorPos = clamp((time - gradient.colors[c-1].w) / (gradient.colors[c].w - gradient.colors[c-1].w), 0.0, 1.0) * step(float(c), gradient.colorsLength-1.0);\n        color = mix(color, gradient.colors[c].rgb, mix(colorPos, step(0.01, colorPos), gradient.type));\n    }\n    \n\n    float alpha = gradient.alphas[0].x;\n    for (int a = 1; a < 8; a++)\n    {\n        float alphaPos = clamp((time - gradient.alphas[a-1].y) / (gradient.alphas[a].y - gradient.alphas[a-1].y), 0.0, 1.0) * step(float(a), gradient.alphasLength-1.0);\n        alpha = mix(alpha, gradient.alphas[a].x, mix(alphaPos, step(0.01, alphaPos), gradient.type));\n    }\n    return vec4(color, alpha);\n    \n            }\n\n// variables\n// </node_builder>\n\n\n\n\n\n\n\n\nvoid main() {\n\n\n\tvec4 diffuseColor = vec4( 1.0, 1.0, 0.0, 1.0 );\n\t\nnodeVar0 = (nodeVary0 * vec2( 1, 1 ) + vec2( 0, 0 ));\n\tnodeVar1 = ( _time * 0.035 );\n\tnodeVar2 = nodeVar1;\n\tnodeVar3 = ( nodeVar0.y + nodeVar2 );\n\tnodeVar4 = vec2(nodeVar3,nodeVar0.x);\n\tnodeVar5 = ( vec3( nodeVar4, 0.0 ) * vec3( 1, 1, 1 ) );\n\tnodeVar6 = customFn_3nW8QQkpfhOY( nodeVar5.xy, 2.0 );\n\tnodeVar7 = customFn_2Vd3wdzIwtQf( nodeVar6 );\n\tnodeVar8 = ( nodeVar0.y + nodeVar2 );\n\tnodeVar9 = vec2(nodeVar8,nodeVar0.x);\n\tnodeVar10 = customFn_unUZVvdgXnqk( nodeVar9, 1.0 );\n\tnodeVar11 = customFn_6SEM4D3cwUVc( nodeVar9, 0.2 );\n\tnodeVar12 = vec2(nodeVar10,nodeVar11);\n\tnodeVar13 = ( nodeVar0 + nodeVar12 );\n\tnodeVar14 = ( vec3( nodeVar13, 0.0 ) * vec3( 1, 1, 1 ) );\n\tnodeVar15 = customFn_UgLkUzErn76G( nodeVar14.xy, 2.0 );\n\tnodeVar16 = customFn_tPu9aVt5rBQE( nodeVar15 );\n\tnodeVar17 = customFn_Bo3YhN5AXwYL( nodeVar7, nodeVar16, 1.0, 1.0 );\n\tnodeVar18 = customFn_vp5SjOUmFgl4( nodeVar15 );\n\tnodeVar19 = customFn_knb8C2HJmfz8( nodeVar17, nodeVar18, 1.0, 1.0 );\n\tnodeVar20 = ( nodeVar19 * vec4( 1, 1, 1, 1 ) );\n\t\n\tdiffuseColor = nodeVar20;\n\n\tgl_FragColor = diffuseColor;\n}\n\n\n",
  cullMode: "back",
  lightModel: "image",
  renderType: "opaque",
};
